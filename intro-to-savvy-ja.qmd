---
title: "**savvy** 入門"
subtitle: "R パッケージで Rust を使う"
author: "@yutannihilation"
format: 
  revealjs:
    theme: ["solarized", "custom.scss"]
    highlight-style: dracula
    code-line-numbers: false
---

# **savvy** とは

## savvy とは

* R パッケージで Rust を使うためのフレームワーク
* Rust のコードを書けば、それを R から使えるようにバインディングを自動生成してくれる

## これが

```rust
/// @export
#[savvy]
fn to_upper(x: StringSexp) -> Result<Sexp> {
    let mut out = OwnedStringSexp::new(x.len())?;

    for (i, e) in x.iter().enumerate() {
        if e.is_na() {
            out.set_na(i)?;
            continue;
        }

        let e_upper = e.to_uppercase();
        out.set_elt(i, e_upper.as_str())?;
    }

    out.into()
}
```

## こうなる

```r
to_upper(c("a", "b", "c"))
#> [1] "A" "B" "C"
```

## 参考）類似のフレームワーク

* **Rcpp**、**cpp11**:  
  R パッケージで C++ を使うフレームワーク
* **PyO3**:  
  Python モジュールで Rust を使うフレームワーク（逆もできる）
* **extendr**:  
  R パッケージで Rust を使うフレームワーク（逆もできる）

## 参考）extendr との関係

* 私が extendr の開発に参加していたときに「extendr が巨大すぎて仕組みを理解できないので、ミニマムなものを自分で作ってみよう！」ということで始めた車輪の再発明プロジェクト
* 最初は unextendr という名前だった

## 参考）extendr との違い

### savvy の利点

* シンプル（欠点でもある）
* 通常の Rust のエラーが使える

### extendr の利点

* 機能が豊富（欠点でもある）
* 使ってる人が多い
* Rust から R を使うこともできる

# なぜ R から Rust の関数が使えるのか

## ※免責事項

がんばって説明を試みますが、素人の知識なので、いろいろ間違っていたり、雑なことを言っている可能性があります。すみません！

## R's C API

「C API」とは？

* C/C++ にとっては、**API**
* 他の言語にとっては、実質 **ABI**

## API と ABI

* **API**: ソースコードレベルで関数やデータの仕様を規定したもの。同じプラットフォーム上で、同じコンパイラでコンパイルすれば互換性がある。
* **ABI**: バイナリレベルで関数やデータの仕様を規定したもの。互換性がある。

::: aside
参考: [APIとかABIとかシステムコールとか - 覚書](https://satoru-takeuchi.hatenablog.com/entry/2020/03/26/011858)
:::

## ABIのイメージ図

![](./images/0-abi.png){fig-align="center" width="100%"}

## "stable" ABI

* ABI とは単に「バイナリの仕様」なので、色々なスコープの ABI がありうる。
* ただ、「ABI」と言う時に欲しいのは、言語やバージョンに寄らない**「stableな」**ABI。

→ 事実上、C の ABI が共通言語として使われる

## 参考) その他の stable ABI

* Swift: mac 限定だが、stable ABI を持っている
* WebAssembly: ブラウザ向けにも OS ネイティブ向けにもまだ stable な ABI はないが、用途から考えるといずれできる？

## 参考) 「C の ABI」などというものがあるのか？

というのは難しくて理解できてません。。

* [Does C have a standard ABI? - Stack Overflow](https://stackoverflow.com/questions/4489012/does-c-have-a-standard-abi)
* [C Isn't A Programming Language Anymore - Faultlore](https://faultlore.com/blah/c-isnt-a-language/)

## R↔Rustのイメージ図

![](./images/2-r-rust.png){fig-align=center}

## R↔Rust

* R は、C ABI がある
* Rust も、C ABI を持つバイナリを生成できる

→ お互いに C ABI を通じて関数を呼び出し合うことができる

## R↔Rust

* ただ、呼び出すときに引数の数や型を揃えないといけなかったり、FFI をまたぐのでエラー処理に気を遣う必要があったりする
* それをゼロから自分でやろうとすると大変だしバグるので、フレームワークをつくって身を任せましょう、という話になる

# savvy で<br/>R パッケージを<br/>つくってみよう

## 0. ヘルパーパッケージをインストール

```r
install.packages(
  "savvy",
  repos = c(
    "https://yutannihilation.r-universe.dev",
    "https://cloud.r-project.org"
  )
)
```

## 1. 空のパッケージを作成

```r
usethis::create_package("../foo")
```

## 2. savvy 関連ファイルを設置

（作成したパッケージのディレクトリに移動後）

```r
savvy::savvy_init()
```

```r
#> Downloading savvy-cli binary
#> trying URL 'https://github.com/yutannihilation/savvy/releases/download/v0.8.0/savvy-cli-x86_64-unknown-linux-gnu.tar.xz'
#> Content type 'application/octet-stream' length 1412628 bytes (1.3 MB)
#> ==================================================
#> downloaded 1.3 MB
#> 
#> Writing ./src/rust/Cargo.toml
#> Writing ./src/rust/.cargo/config.toml
#> ...
```

## （Windows の場合のみ）

Git を使うなら、 `configure` と `cleanup` には実行権限をつける。

```sh
git update-index --add --chmod=+x ./configure ./configure.win ./cleanup ./cleanup.win
```

## 3. ドキュメント生成

Rust コードのコンパイルも実行される。

```r
devtools::document()
```

```r
#> ℹ Updating foo documentation
#> Writing NAMESPACE
#> ℹ Loading foo
#> ℹ Re-compiling foo (debug build)
#> ── R CMD INSTALL ────────────────────────────────
#> ...
#> ─  DONE (foo)
#> Writing NAMESPACE
#> Writing to_upper.Rd
#> Writing int_times_int.Rd
```

## パッケージの構造

```
.
├── .Rbuildignore
├── DESCRIPTION
├── NAMESPACE
├── R
│   └── 000-wrappers.R
├── configure
├── configure.win
├── cleanup
├── cleanup.win
├── foo.Rproj
└── src
    ├── Makevars.in
    ├── Makevars.win.in
    ├── init.c
    ├── foo-win.def
    └── rust
        ├── .cargo
        │   └── config.toml
        ├── api.h
        ├── Cargo.toml
        └── src
            └── lib.rs
```

## 主なファイル

* **`src/rust/src/lib.rs`**: Rust のコード

* **`src/rust/api.h`**: コンパイルされた Rust の関数を C から呼び出すためのヘッダファイル（自動生成）

* **`src/init.c`**: コンパイルされた Rust の関数を R から呼び出すための C コード（自動生成）

* **`R/000-wrappers.R`**: コンパイルされた Rust の関数を呼び出す R コード（自動生成）
  
## Rust のコード

`///` 後のコメントは R の roxygen コメントに

```rust
/// Convert Input To Upper-Case
///
/// @param x A character vector.
/// @returns A character vector with upper case version of the input.
/// @export
#[savvy]
fn to_upper(x: StringSexp) -> savvy::Result<savvy::Sexp> {
    let mut out = OwnedStringSexp::new(x.len())?;
    ...
```

## `api.h`

```c
SEXP savvy_to_upper__ffi(SEXP c_arg__x);
```

## `init.c`

エラー処理などの関数でラップ

```c
SEXP savvy_to_upper__impl(SEXP c_arg__x) {
    SEXP res = 
      savvy_to_upper__ffi(c_arg__x);
    return handle_result(res);
}
```

## `init.c`（続き）

R から `.Call()` で呼び出せるように登録

```c
static const R_CallMethodDef CallEntries[] = {
    {"savvy_to_upper__impl",
      (DL_FUNC) &savvy_to_upper__impl, 1},
    {NULL, NULL, 0}
};

void R_init_foo(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
```

## R のコード

```r
#' Convert Input To Upper-Case
#'
#' @param x A character vector.
#' @returns A character vector with upper case version of the input.
#' @export
`to_upper` <- function(`x`) {
  .Call(savvy_to_upper__impl, `x`)
}
```

## 使ってみる

```r
devtools::load_all()
#> ℹ Loading foo

to_upper(c("a", "b", "c"))
#> [1] "A" "B" "C"
```
